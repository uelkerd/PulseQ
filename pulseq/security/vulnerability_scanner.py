"""
Vulnerability Scanner Module

Provides comprehensive security scanning capabilities for code and configuration.
"""

import os
import re
import ast
from typing import Dict, Any, List, Optional
import logging
from pathlib import Path

class VulnerabilityScanner:
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.logger = logging.getLogger(__name__)
        self.patterns = self._load_security_patterns()

    def _load_security_patterns(self) -> Dict[str, List[str]]:
        """Load security patterns for scanning"""
        return {
            'sensitive_data': [
                r'password\s*=\s*[\'"].*?[\'"]',
                r'api_key\s*=\s*[\'"].*?[\'"]',
                r'secret\s*=\s*[\'"].*?[\'"]',
                r'token\s*=\s*[\'"].*?[\'"]'
            ],
            'insecure_crypto': [
                r'MD5\(',
                r'SHA1\(',
                r'DES\(',
                r'RC4\('
            ],
            'sql_injection': [
                r'execute\s*\(.*?\+.*?\)',
                r'executemany\s*\(.*?\+.*?\)',
                r'raw\s*\(.*?\+.*?\)'
            ],
            'xss': [
                r'innerHTML\s*=\s*.*?\+.*?',
                r'outerHTML\s*=\s*.*?\+.*?',
                r'write\s*\(.*?\+.*?\)'
            ],
            'command_injection': [
                r'os\.system\s*\(.*?\+.*?\)',
                r'subprocess\.run\s*\(.*?\+.*?\)',
                r'Popen\s*\(.*?\+.*?\)'
            ]
        }

    def scan_file(self, file_path: str) -> List[Dict[str, Any]]:
        """Scan a single file for vulnerabilities"""
        vulnerabilities = []
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()
                
                # Check for sensitive data
                for pattern in self.patterns['sensitive_data']:
                    matches = re.finditer(pattern, content)
                    for match in matches:
                        vulnerabilities.append({
                            'type': 'sensitive_data',
                            'severity': 'high',
                            'line': self._get_line_number(content, match.start()),
                            'description': 'Potential sensitive data exposure',
                            'code': match.group()
                        })
                
                # Check for insecure crypto
                for pattern in self.patterns['insecure_crypto']:
                    matches = re.finditer(pattern, content)
                    for match in matches:
                        vulnerabilities.append({
                            'type': 'insecure_crypto',
                            'severity': 'high',
                            'line': self._get_line_number(content, match.start()),
                            'description': 'Use of insecure cryptographic algorithm',
                            'code': match.group()
                        })
                
                # Check for SQL injection
                for pattern in self.patterns['sql_injection']:
                    matches = re.finditer(pattern, content)
                    for match in matches:
                        vulnerabilities.append({
                            'type': 'sql_injection',
                            'severity': 'high',
                            'line': self._get_line_number(content, match.start()),
                            'description': 'Potential SQL injection vulnerability',
                            'code': match.group()
                        })
                
                # Check for XSS
                for pattern in self.patterns['xss']:
                    matches = re.finditer(pattern, content)
                    for match in matches:
                        vulnerabilities.append({
                            'type': 'xss',
                            'severity': 'high',
                            'line': self._get_line_number(content, match.start()),
                            'description': 'Potential XSS vulnerability',
                            'code': match.group()
                        })
                
                # Check for command injection
                for pattern in self.patterns['command_injection']:
                    matches = re.finditer(pattern, content)
                    for match in matches:
                        vulnerabilities.append({
                            'type': 'command_injection',
                            'severity': 'high',
                            'line': self._get_line_number(content, match.start()),
                            'description': 'Potential command injection vulnerability',
                            'code': match.group()
                        })
                
                # Check for AST-based vulnerabilities
                vulnerabilities.extend(self._scan_ast(file_path))
                
        except Exception as e:
            self.logger.error(f"Error scanning file {file_path}: {str(e)}")
        
        return vulnerabilities

    def _get_line_number(self, content: str, position: int) -> int:
        """Get line number from position in content"""
        return content[:position].count('\n') + 1

    def _scan_ast(self, file_path: str) -> List[Dict[str, Any]]:
        """Scan file using AST for more complex vulnerabilities"""
        vulnerabilities = []
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                tree = ast.parse(f.read())
                
                # Check for eval/exec usage
                for node in ast.walk(tree):
                    if isinstance(node, ast.Call):
                        if isinstance(node.func, ast.Name):
                            if node.func.id in ['eval', 'exec']:
                                vulnerabilities.append({
                                    'type': 'code_execution',
                                    'severity': 'high',
                                    'line': node.lineno,
                                    'description': 'Use of eval/exec can lead to code injection',
                                    'code': ast.get_source_segment(f.read(), node)
                                })
                
                # Check for pickle usage
                for node in ast.walk(tree):
                    if isinstance(node, ast.Import):
                        for name in node.names:
                            if name.name == 'pickle':
                                vulnerabilities.append({
                                    'type': 'insecure_deserialization',
                                    'severity': 'high',
                                    'line': node.lineno,
                                    'description': 'Use of pickle can lead to insecure deserialization',
                                    'code': ast.get_source_segment(f.read(), node)
                                })
                
        except Exception as e:
            self.logger.error(f"Error scanning AST for {file_path}: {str(e)}")
        
        return vulnerabilities

    def scan_directory(self, directory: str) -> Dict[str, Any]:
        """Scan entire directory for vulnerabilities"""
        results = {
            'total_files': 0,
            'vulnerabilities': [],
            'summary': {
                'high': 0,
                'medium': 0,
                'low': 0
            }
        }
        
        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith(('.py', '.js', '.ts', '.java', '.go')):
                    file_path = os.path.join(root, file)
                    results['total_files'] += 1
                    file_vulnerabilities = self.scan_file(file_path)
                    results['vulnerabilities'].extend(file_vulnerabilities)
                    
                    # Update summary
                    for vuln in file_vulnerabilities:
                        results['summary'][vuln['severity']] += 1
        
        return results

    def generate_scan_report(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate comprehensive scan report"""
        return {
            'timestamp': datetime.utcnow().isoformat(),
            'scan_summary': scan_results['summary'],
            'total_files_scanned': scan_results['total_files'],
            'vulnerabilities_found': len(scan_results['vulnerabilities']),
            'vulnerabilities': scan_results['vulnerabilities'],
            'recommendations': self._generate_recommendations(scan_results)
        }

    def _generate_recommendations(self, scan_results: Dict[str, Any]) -> List[str]:
        """Generate security recommendations based on scan results"""
        recommendations = []
        
        if scan_results['summary']['high'] > 0:
            recommendations.append("Critical: Address high severity vulnerabilities immediately")
        
        if scan_results['summary']['medium'] > 0:
            recommendations.append("Important: Review and fix medium severity vulnerabilities")
        
        if scan_results['summary']['low'] > 0:
            recommendations.append("Consider: Address low severity vulnerabilities")
        
        return recommendations 